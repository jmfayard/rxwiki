These operators have been proposed but are not part of the anticipated 1.0 release of RxJava.

* [**`chunkify( )`**](Phantom-Operators#wiki-chunkify) — returns an iterable that periodically returns a list of items emitted by the source Observable since the last list
* [**`fromFuture( )`**](Phantom-Operators#wiki-fromfuture) — convert a Future into an Observable, but do not attempt to get the Future's value until a Subscriber subscribes
* [**`forEachFuture( )`**](Phantom-Operators#wiki-foreachfuture) — create a futureTask that will invoke a specified function on each item emitted by an Observable 
* [**`forIterable( )`**](Phantom-Operators#wiki-foriterable) — apply a function to the elements of an Iterable to create Observables which are then concatenated
* [**`fromCancellableFuture( )`, `startCancellableFuture( )`, and `deferCancellableFuture( )`**](Phantom-Operators#wiki-fromcancellablefuture-startcancellablefuture-and-defercancellablefuture-) — versions of Future-to-Observable converters that monitor the subscription status of the Observable to determine whether to halt work on the Future
* [**`generate( )` and `generateAbsoluteTime( )`**](Phantom-Operators#wiki-generate-and-generateabsolutetime) — create an Observable that emits a sequence of items as generated by a function of your choosing
* [**`pivot( )`**](Phantom-Operators#pivot) — combine multiple sets of grouped observables so that they are arranged primarily by group rather than by set

***

## chunkify( )
#### returns an iterable that periodically returns a list of items emitted by the source Observable since the last list
<img src="/Netflix/RxJava/wiki/images/rx-operators/B.chunkify.png" width="640" height="490" />

The `chunkify( )` operator represents a blocking observable as an Iterable, that, each time you iterate over it, returns a list of items emitted by the source Observable since the previous iteration. These lists may be empty if there have been no such items emitted.

***

## fromFuture( )
#### convert a Future into an Observable, but do not attempt to get the Future's value until a Subscriber subscribes
<img src="/Netflix/RxJava/wiki/images/rx-operators/fromFuture.png" width="640" height="335" />

The `fromFuture( )` method also converts a Future into an Observable, but it obtains this Future indirectly, by means of a function you provide. It creates the Observable immediately, but waits to call the function and to obtain the Future until a Subscriber subscribes to it.

***

## forEachFuture( )
#### create a futureTask that will invoke a specified function on each item emitted by an Observable 
<img src="/Netflix/RxJava/wiki/images/rx-operators/B.forEachFuture.png" width="640" height="375" />

The `forEachFuture( )` returns a `FutureTask` for each item emitted by the source Observable (or each item and each notification) that, when executed, will apply a function you specify to each such item (or item and notification).

***

## forIterable( )
#### apply a function to the elements of an Iterable to create Observables which are then concatenated
<img src="/Netflix/RxJava/wiki/images/rx-operators/forIterable.png" width="640" height="310" />

`forIterable( )` is similar to `from(Iterable )` but instead of the resulting Observable emitting the elements of the Iterable as its own emitted items, it applies a specified function to each of these elements to generate one Observable per element, and then concatenates the emissions of these Observables to be its own sequence of emitted items.

***

## fromCancellableFuture( ), startCancellableFuture( ), and deferCancellableFuture( )
#### versions of Future-to-Observable converters that monitor the subscription status of the Observable to determine whether to halt work on the Future

If the a subscriber to the Observable that results when a Future is converted to an Observable later unsubscribes from that Observable, it can be useful to have the ability to stop attempting to retrieve items from the Future. The "cancellable" Future enables you do do this. These three methods will return Observables that, when unsubscribed to, will also "unsubscribe" from the underlying Futures.

***

## generate( ) and generateAbsoluteTime( )
#### create an Observable that emits a sequence of items as generated by a function of your choosing
<img src="/Netflix/RxJava/wiki/images/rx-operators/generate.png" width="640" height="315" />

The basic form of `generate( )` takes four parameters. These are `initialState` and three functions: `iterate( )`, `condition( )`, and `resultSelector( )`. `generate( )` uses these four parameters to generate an Observable sequence, which is its return value. It does so in the following way.

`generate( )` creates each emission from the sequence by applying the `resultSelector( )` function to the current _state_ and emitting the resulting item. The first state, which determines the first emitted item, is `initialState`. `generate( )` determines each subsequent state by applying `iterate( )` to the current state. Before emitting an item, `generate( )` tests the result of `condition( )` applied to the current state. If the result of this test is `false`, instead of calling `resultSelector( )` and emitting the resulting value, `generate( )` terminates the sequence and stops iterating the state.

There are also versions of `generate( )` that allow you to do the work of generating the sequence on a particular `Scheduler` and that allow you to set the time interval between emissions by applying a function to the current state. The `generateAbsoluteTime( )` allows you to control the time at which an item is emitted by applying a function to the state to get an absolute system clock time (rather than an interval from the previous emission).

<img src="/Netflix/RxJava/wiki/images/rx-operators/generateAbsoluteTime.png" width="640" height="330" />

#### see also:
* <a href="http://www.introtorx.com/Content/v1.0.10621.0/04_CreatingObservableSequences.html#ObservableGenerate">Introduction to Rx: Generate</a>
* Linq: <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.generate.aspx">`Generate`</a>
* RxJS: <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablegenerateinitialstate-condition-iterate-resultselector-scheduler">`generate`</a>, <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablegeneratewithabsolutetimeinitialstate-condition-iterate-resultselector-timeselector-scheduler">`generateWithAbsoluteTime`</a>, and <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablegeneratewithrelativetimeinitialstate-condition-iterate-resultselector-timeselector-scheduler">`generateWithRelativeTime`</a>

***

## pivot( )
#### combine multiple sets of grouped observables so that they are arranged primarily by group rather than by set
<img src="/Netflix/RxJava/wiki/images/rx-operators/pivot.png" width="640" height="580" />​

If you combine multiple sets of grouped observables, such as those created by [`groupBy( )` and `groupByUntil( )`](Transforming-Observables#wiki-groupby-and-groupbyuntil), then even if those grouped observables have been grouped by a similar differentiation function, the resulting grouping will be primarily based on which set the observable came from, not on which group the observable belonged to.

An example may make this clearer. Imagine you use `groupBy( )` to group the emissions of an Observable (Observable1) that emits integers into two grouped observables, one emitting the even integers and the other emitting the odd integers. You then repeat this process on a second Observable (Observable2) that emits another set of integers. You hope then to combine the sets of grouped observables emitted by each of these into a single grouped Observable by means of a operator like `from(Observable1, Observable2)`.

The result will be a grouped observable that emits two groups: the grouped observable resulting from transforming Observable1, and the grouped observable resulting from transforming Observable2. Each of those grouped observables emit observables that in turn emit the odds and evens from the source observables. You can use `pivot( )` to change this around: by applying `pivot( )` to this grouped observable it will transform into one that emits two different groups: the odds group and the evens group, with each of these groups emitting a separate observable corresponding to which source observable its set of integers came from. Here is an illustration:

<img src="/Netflix/RxJava/wiki/images/rx-operators/pivot.ex.png" width="640" height="1140" />​